<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: TrackGenerator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: TrackGenerator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module TrackGenerator
 * @version 1.0.0
 * @author JosÃ© Carlos
 * @desc This module generates randomly the 2D driving simulator, straight lines only version, using HTML5 Canvas.
 *
 * @date Apr 02, 2018
 * last modified @date Apr 18, 2018
 *
 * @example &lt;caption>Usage of TrackGenerator within a PVSio-web demo.&lt;/caption>
 * define(function (require, exports, module) {
 *     "use strict";
 *
 *     // Require the TrackGenerator module
 *     require("widgets/car/TrackGenerator");
 *
 *     function main() {
 *          // After TrackGenerator module was loaded, initialize it
 *          let TrackGenerator = new TrackGenerator(
 *               'example', // id of the TrackGenerator element that will be created
 *               { top: 100, left: 700, width: 500, height: 500 }, // coordinates object
 *               { 
 *                  parent: "content", // defines parent div, which is div id="content" by default
 *                  spritesFilename: "spritesheet", // defines spritesheet configuration filename, which is "spritesheet.json" by default
 *                  render: {
 *                      width: 320,
 *                      height: 240,
 *                      depthOfField: 150,
 *                      camera_distance: 30,
 *                      camera_height: 100
 *                  },
 *                  trackSegmentSize: 5,
 *                  numberOfSegmentPerColor: 4,
 *                  numLanes: 3,
 *                  laneWidth: 0.02,
 *                  trackParam: {
 *                      maxHeight: 900,
 *                      maxCurve:  400,
 *                      numZones:    12, // number of different portions of the track
 *                      curvy:     0.8,
 *                      mountainy: 0.8,
 *                      zoneSize:  250 // length of each numZones (the bigger this value. the longer it will take to finish)
 *                  },
 *                  // Information regarding current controllable_car's car
 *                  controllable_car: {
 *                      position: 10,
 *                      speed: 0,
 *                      acceleration: 0.05,
 *                      deceleration: 0.04,
 *                      breaking: 0.3,
 *                      turning: 5.0,
 *                      posx: 0,
 *                      maxSpeed: 20
 *                  },
 *                  topSpeed: 250,
 *                  objects: ["tree","boulder"], // sprite names to be drawed in the landscape
 *                  obstacle: ["boulder"], // sprite names to be drawed within the track as obstacles
 *                  obstaclePerIteration: 50, // each 50 iterations a new obstacle will be placed within the track
 *                  trackLayout: [ 
 *                       // describing the desired track, which is 2 straight lines, followed by curve to left, straight line, 
 *                       // curve to right, straight line, 2 up slopes, curve to left, down slope, curve to right,
 *                       // straight line, each with 3 zones (length) (default is []).
 *                       {
 *                           topography: "plain",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "plain",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "left",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "plain",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "right",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "plain",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "up",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "up",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "left",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "down",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "right",
 *                           numZones: 3
 *                       },
 *                       {
 *                           topography: "plain",
 *                           numZones: 3
 *                       }
 *                   ],
 *              } // append on div 'content'
 *           );
 * 
 *          // Render the TrackGenerator widget
 *          TrackGenerator.render();
 * 
 *          // Hides the TrackGenerator widget
 *          TrackGenerator.hide();
 * 
 *          // Reveals the TrackGenerator widget
 *          TrackGenerator.reveal();
 * 
 *          // Generates randomly the track, with only straight lines (i.e. height:0, curves:0)
 *          TrackGenerator.generateStraightTrack();
 * 
 *          // Generates randomly the track, with straight lines, curves and slopes
 *          TrackGenerator.generateTrackCurvesSlopes();
 * 
 *     }
 * });
 */
/*jslint lets: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */
/*jshint esnext:true */

require.config({
    baseUrl: "../../client/app",
    paths: {
        jquery: '../lib/jquery.js'
    }
});

/*global define*/
define(function (require, exports, module) {
    "use strict";

    let Widget = require("widgets/Widget");

    let spritesheetJSON,spritesReadJSON;

    // Random numbers to place sprites randomly within the landscape territory
    let randomPos = Math.random;
    let generatedTrack=[];
    let generatedObstacles=[];

    // Global Variables for opt fields
    let render;
    let trackSegmentSize;
    let numberOfSegmentPerColor;
    let numLanes;
    let laneWidth;
    let params;
    let trackParam;
    let controllable_car;
    let topSpeed;
    let spritesAvailable=[];
    let objects = [];
    let obstacle = [];
    let trackLayout = [];
    let obstaclePerIteration;

    // Has the produced JSON.
    let generatedJSON;

    /**
     * @function constructor
     * @description Constructor for the TrackGenerator widget.
     * @param id {String} The id of the widget instance.
     * @param coords {Object} The four coordinates (top, left, width, height) of the display, specifying
     *        the left, top corner, and the width and height of the (rectangular) display.
     *        Default is { top: 1000, left: 100, width: 500, height: 500 }.
     * @param opt {Object} Options:
     *          &lt;li>parent {String}: the HTML element where the display will be appended (default is "game-window").&lt;/li>
     *          &lt;li>spritesFilename {String}: the spritesheet filename(json file) that will be loaded (default is "spritesheet").&lt;/li>
     *          &lt;li>render {Object}: the rendering configurations, i.e. width, height, etc. (default is  {width: 320, height: 240, depthOfField: 150, camera_distance: 30, camera_height: 100}).&lt;/li>
     *          &lt;li>trackSegmentSize {Int}: the size of the track segment (default is 5).&lt;/li>
     *          &lt;li>numberOfSegmentPerColor {Int}: the number of segments per color, i.e. how many sequenced segments to alternate colors (default is 4).&lt;/li>
     *          &lt;li>numLanes {Int}: the number of lanes the track will be draw (default is 3).&lt;/li>
     *          &lt;li>laneWidth {Float}: the width of the lane separator (default is 0.02).&lt;/li>
     *          &lt;li>trackParam {Object}: the track configurations, i.e. number of zones(track length), etc (default is {maxHeight: 900, maxCurve:  400, numZones: 12, curvy: 0.8, mountainy: 0.8, zoneSize: 250}).&lt;/li>
     *          &lt;li>controllable_car {Object}: the vehicle configurations, i.e. initial position, acceleration and deceleration values, etc (default is {position: 10, speed: 0, acceleration: 0.05, deceleration: 0.04, breaking: 0.3, turning: 5.0, posx: 0, maxSpeed: 20}).&lt;/li>
     *          &lt;li>topSpeed {Int}: the maximum speed value that can be reached (default is 250).&lt;/li>
     *          &lt;li>objects {Array}: the sprite names to be drawed in the landscape (default is ["tree","rock"]).&lt;/li>
     *          &lt;li>obstacle {Array}: the sprite names to be drawed within the track as obstacles (default is ["rock"]).&lt;/li>
     *          &lt;li>trackLayout {Array}: the track layout that will be used to create the corresponding segments. (default is []).&lt;/li>
     *          &lt;li>obstaclePerIteration {Int}: the number of iterations where a new obstacle will be placed within the track (default is 50).&lt;/li>
     * @returns {TrackGenerator} The created instance of the widget TrackGenerator.
     * @memberof module:TrackGenerator
     * @instance
     */
    function TrackGenerator(id, coords, opt) {
        opt = opt || {};
        coords = coords || {};
        opt.parent = opt.parent || "game-window";
        opt.spritesFilename = opt.spritesFilename;        
        opt.render = opt.render;
        opt.trackSegmentSize = opt.trackSegmentSize;
        opt.numberOfSegmentPerColor = opt.numberOfSegmentPerColor;
        opt.numLanes = opt.numLanes;
        opt.laneWidth = opt.laneWidth;
        // opt.params = opt.params;
        opt.trackParam = opt.trackParam; 
        opt.controllable_car = opt.controllable_car;
        opt.topSpeed = opt.topSpeed;
        opt.objects = opt.objects;
        opt.obstacle = opt.obstacle;
        opt.trackLayout = opt.trackLayout;
        opt.obstaclePerIteration = opt.obstaclePerIteration;

        this.id = id;
        this.top = coords.top || 100;
        this.left = coords.left || 700;
        this.width = coords.width || 750;
        this.height = coords.height || 750;

        render                  = (opt.render) ? opt.render : { width: 320, height: 240, depthOfField: 150, camera_distance: 30, camera_height: 100 };
        trackSegmentSize        = (opt.trackSegmentSize) ? opt.trackSegmentSize : 5;
        numberOfSegmentPerColor = (opt.numberOfSegmentPerColor) ? opt.numberOfSegmentPerColor : 4;
        numLanes                = (opt.numLanes) ? opt.numLanes : 3;
        laneWidth               = (opt.laneWidth) ? opt.laneWidth: 0.02;
        trackParam              = (opt.trackParam) ? opt.trackParam : { maxHeight: 900, maxCurve: 400, numZones: 12, /*number of different portions of the track*/ curvy: 0.8, mountainy: 0.8, zoneSize:  250 /*length of each numZones (the bigger this value. the longer it will take to finish)*/ };        
        // params                  = (opt.params) ? opt.params : { maxHeight: 900, maxCurve: 400, numZones: 12, /*number of different portions of the track*/ curvy: 0.8, mountainy: 0.8, zoneSize:  250 /*length of each numZones (the bigger this value. the longer it will take to finish)*/ };        
        params=JSON.parse(JSON.stringify(trackParam));
        controllable_car        = (opt.controllable_car) ? opt.controllable_car : { position: 10, speed: 0, acceleration: 0.05, deceleration: 0.04, breaking: 0.3, turning: 5.0, posx: 0, maxSpeed: 20 };
        topSpeed                = (opt.topSpeed) ? opt.topSpeed : 250;

        objects  = (opt.objects) ? opt.objects : ["tree","boulder"];
        obstacle = (opt.obstacle) ? opt.obstacle : ["boulder"];
        trackLayout = (opt.trackLayout) ? opt.trackLayout : [];
        obstaclePerIteration = (opt.obstaclePerIteration) ? opt.obstaclePerIteration : 50;

        console.log(trackLayout);

        this.parent = (opt.parent) ? ("#" + opt.parent) : "game-window";
        this.spritesFilename = (opt.spritesFilename) ? ("text!widgets/car/configurations/" + opt.spritesFilename + ".json") : "text!widgets/car/configurations/spritesheet.json";
        
        spritesheetJSON = require("text!widgets/car/configurations/spritesheet.json");        

        this.div = d3.select(this.parent);
        
        this.div.append("h2").text("Track Generator");
        this.div.append("span")
                .attr("id","created")
                .text("Success: False");

        opt.callback = opt.callback || function () {};
        this.callback = opt.callback;

        if(spritesheetJSON){
            spritesReadJSON = JSON.parse(spritesheetJSON);
            // Reading all JSON Sprites Available
            for(let k=0;k&lt;spritesReadJSON.frames.length;k++){
                spritesAvailable[k]={
                    name:spritesReadJSON.frames[k].filename.split(".")[0],
                    value:spritesReadJSON.frames[k].frame
                };
            }    
        }

        // console.log(spritesAvailable);
    
        Widget.call(this, id, coords, opt);
        // TrackGenerator.prototype.generateStraightTrack();
        TrackGenerator.prototype.generateTrackCurvesSlopes();

        // TODO writeFile track.json with its content with Paolo Masci new API (when it has been implemented)
        // console.log(generatedJSON);
        console.log(JSON.stringify(generatedJSON));

        return this;
    }

    TrackGenerator.prototype = Object.create(Widget.prototype);
    TrackGenerator.prototype.constructor = TrackGenerator;
    TrackGenerator.prototype.parentClass = Widget.prototype;

    /**
     * @function hide
     * @description Hide method of the TrackGenerator widget. This method changes the current main div visibility to 'hidden'.
     * @memberof module:TrackGenerator
     * @instance
     */
    TrackGenerator.prototype.hide = function () {
        return this.div.style("visibility", "hidden");
    };

    /**
     * @function reveal
     * @description Reveal method of the TrackGenerator widget. This method changes the current main div visibility to 'visible'.
     * @memberof module:TrackGenerator
     * @instance
     */
    TrackGenerator.prototype.reveal = function () {
        return this.div.style("visibility", "visible");
    };

     /**
     * @function generateStraightTrack
     * @description GenerateStraightTrack method of the TrackGenerator widget. This method generates the straight line simulator version.
     * Every 50 iterations an obstacle is randomly placed on a part of the track, i.e. between the track and landscape separators.
Â Â Â Â Â * The sprite variable has the information about whether or not it is an obstacle in the obstacle field (1-yes, 0-no).
Â Â Â Â Â * It also has information about the randomly generated position and the type of sprite, i.e. the sprite provided as opt from the available list (obtained in the spritesheet.json file)
Â Â Â Â Â * During the remaining iterations (which will not be considered as obstacles on the road), a value is randomly generated to decide in which side it will be placed (spriteSidesRandom).
Â Â Â Â Â * Then the position on that side is also randomly generated in spritePos (given by spritePosRightRandom or spritePosLeftRandom).
Â Â Â Â Â * Before finishing, another random number is generated to know how far to put the sprite on the selected side in relation to the landscape/track separator, in order to have
Â Â Â Â Â * sprites randomly scattered, but balanced (instead of being concentrated in a given area).
Â Â Â Â Â * After creating the segments that make up the track, on generatedTrack variable, that includes information on what sprites to put in and whether those are obstacles or not,
Â Â Â Â Â * a JSON object, generatedJSON, is created, which will later be saved in a track.json file in the widgets/car/configurations directory, when there is a file writing API
Â Â Â Â Â * within this context on the PVSio-web platform.
     * @memberof module:TrackGenerator
     * @instance
     */
    TrackGenerator.prototype.generateStraightTrack = () => {
        // Generate current Zone
        let numIterations = params.numZones * params.zoneSize;
        let sprite = false;
        let spritePos = null;
        let spritePosgeneratedObstaclesRandom = null;
        let spritePosRightRandom = null;
        let spritePosLeftRandom =  null;
        let spriteTypeRandom = null;
        let spriteSidesRandom = null;
        let spritesAvailableLength = spritesAvailable.length;
    
        for(let i=0; i &lt; numIterations; i++){            
            // generates random integer numbers between 0 and spritesAvailable.length
            spriteTypeRandom = Math.floor(randomPos() * spritesAvailableLength);
            // generates random integer numbers between 1 and 2
            spriteSidesRandom = Math.floor((randomPos() * 2) + 1);
    
            spritePosgeneratedObstaclesRandom = randomPos() - 0.5;
            
            if(spritesAvailable[spriteTypeRandom].name.match(/car[0-9]?/)===null &amp;&amp; spritesAvailable[spriteTypeRandom].name.match(/background[0-9]?/)===null &amp;&amp; spritesAvailable[spriteTypeRandom].name.match(/logo[0-9]?/)===null){
                if(i%obstaclePerIteration===0){
                    obstacle.forEach((element) => {
                        let index = spritesAvailable.findIndex(el => el.name === element);
                        // console.log(index);
                        // each obstaclePerIteration iterations a new obstacle is placed within the generatedTrack
                        // console.log(spritePosgeneratedObstaclesRandom);
                        generatedObstacles.push(spritePosgeneratedObstaclesRandom);
                        // spritePosgeneratedObstaclesRandom has the relative position of the obstacle
                        sprite = {type: spritesAvailable[index].value, pos: spritePosgeneratedObstaclesRandom, obstacle: 1};
                        
                        generatedTrack.push({
                            height: 0,
                            curve: 0,
                            sprite: sprite
                        });
                    });
                }else{
                    objects.forEach((element) => {
                        // console.log(element);
                        let index = spritesAvailable.findIndex(el => el.name === element);
                        // console.log(index);
                        // generates random float numbers greater than 0.55
                        spritePosRightRandom = randomPos() + 0.90;
                        // generates random float numbers lesser than -0.55
                        spritePosLeftRandom =  (randomPos() * -0.56) - 0.56;
    
                        // choose randomly sprite size
                        if(spriteSidesRandom === 1){
                            spritePos = spritePosLeftRandom;
                        }else if(spriteSidesRandom === 2){
                            spritePos = spritePosRightRandom;
                        }
    
                        if(randomPos() &lt; 0.25){
                            sprite = {type: spritesAvailable[index].value, pos: spritePos-0.5, obstacle: 0};
                        } if(randomPos() &lt; 0.5){
                            sprite = {type: spritesAvailable[index].value, pos: spritePos, obstacle: 0};
                        }else{
                            sprite = {type: spritesAvailable[index].value, pos: 3*spritePos, obstacle: 0};
                        }

                        // console.log(sprite.type);
                        generatedTrack.push({
                            height: 0,
                            curve: 0,
                            sprite: sprite
                        });
                    });
                }
            }
        }

        params.numZones = numIterations; 

        generatedJSON = {
            controllable_car: controllable_car,
            laneWidth: laneWidth,
            numLanes: numLanes,
            numberOfSegmentPerColor: numberOfSegmentPerColor,
            render: render,
            topSpeed: topSpeed,
            track: generatedTrack,
            trackParam: trackParam,
            trackSegmentSize: trackSegmentSize,
            trackColors: {
                grass1: "#699864",
                border1: "#e00",
                border2: "#fff",
                outborder1: "#496a46",
                outborder_end1: "#474747",
                track_segment1: "#777",
                lane1: "#fff",
                lane2: "#777",
                laneArrow1: "#00FF00",
                track_segment_end:"#000",
                lane_end: "#fff"
            }
        };

        setTimeout(function(){ d3.select("#created").text("Success: True"); }, 1500);
        
        return this;
    };

    /**
     * @function generateTrackCurvesSlopes
     * @description GenerateTrackCurvesSlopes method of the TrackGenerator widget. This method generates the straight line simulator version.
     * Every 50 iterations an obstacle is randomly placed on a part of the track, i.e. between the track and landscape separators.
Â Â Â Â Â * The sprite variable has the information about whether or not it is an obstacle in the obstacle field (1-yes, 0-no).
Â Â Â Â Â * It also has information about the randomly generated position and the type of sprite, i.e. the sprite provided as opt from the available list (obtained in the spritesheet.json file)
Â Â Â Â Â * During the remaining iterations (which will not be considered as obstacles on the road), a value is randomly generated to decide in which side it will be placed (spriteSidesRandom).
Â Â Â Â Â * Then the position on that side is also randomly generated in spritePos (given by spritePosRightRandom or spritePosLeftRandom).
Â Â Â Â Â * Before finishing, another random number is generated to know how far to put the sprite on the selected side in relation to the landscape/track separator, in order to have
Â Â Â Â Â * sprites randomly scattered, but balanced (instead of being concentrated in a given area).
Â Â Â Â Â * After creating the segments that make up the track, on generatedTrack variable, that includes information on what sprites to put in and whether those are obstacles or not,
Â Â Â Â Â * a JSON object, generatedJSON, is created, which will later be saved in a track.json file in the widgets/car/configurations directory, when there is a file writing API
Â Â Â Â Â * within this context on the PVSio-web platform.
     * @memberof module:TrackGenerator
     * @instance
     */
    TrackGenerator.prototype.generateTrackCurvesSlopes = () => {
        // Generate current Zone
        let sprite = false;
        let spritePos = null;
        let spritePosgeneratedObstaclesRandom = null;
        let spritePosRightRandom = null;
        let spritePosLeftRandom =  null;
        let spriteTypeRandom = null;
        let chooseIndexFromObjects=null;
        let chooseObjectFromDesiredObjects=null;
        let chooseIndexFromObstacle=null;
        let chooseObstacleFromDesiredObstacle=null;
        let spriteSidesRandom = null;
        let slopesTransitionRandom = null;
        let curvesTransitionRandom = null;
        let spritesAvailableLength = spritesAvailable.length;
        let index=null;

        let heightType = 0; //0=plain 1=up -1=down
        let slopesTransitions = {
            plainToUpToDownTransition: [0,1,-1],
            plainToDownToDownTransition: [0,-1,-1],
            plainToUpToUpTransition: [0,1,1]
        };

        let curveType = 0; //0=straight 1=left -1=right
        let curvesTransitions = {
            straightToLeftToRightTransition: [0,1,-1],
            straightToRightToRightTransition: [0,-1,-1],
            straightToLeftToLeftTransition: [0,1,1]
        };

        let currentZone = {
            height: 0,
            curve: 0
        };

        // console.log("trackParam.numZones: "+trackParam.numZones);

        let iter = params.numZones;
        // console.log("iter: "+iter);
        // console.log("params.numZones: "+params.numZones);

        while(iter){
            // Generate current Zone
            let intendedHeightForCurrentZone;
            switch(heightType){
                case 0:
                    intendedHeightForCurrentZone = 0; break;
                case 1:
                    intendedHeightForCurrentZone = params.maxHeight * randomPos(); break;
                case -1:
                    intendedHeightForCurrentZone = - params.maxHeight * randomPos(); break;
            }
            let intendedCurveForCurrentZone;
            switch(curveType){
                case 0:
                    intendedCurveForCurrentZone = 0; break;
                case 1:
                    intendedCurveForCurrentZone = - params.maxCurve * randomPos(); break;
                case -1:
                    intendedCurveForCurrentZone = params.maxCurve * randomPos(); break;
            }
            
            for(let i=0; i &lt; params.zoneSize; i++){
                // generates random integer numbers between 0 and 100(there are 101 sprites available)
                spriteTypeRandom = Math.floor((randomPos() * 101));

                // generates random integer numbers between 0 and objects.length(there are objects.length sprites desired to draw)
                chooseIndexFromObjects = Math.floor((randomPos() * objects.length));
                chooseObjectFromDesiredObjects=objects[chooseIndexFromObjects];
                index = spritesAvailable.findIndex(el => el.name === chooseObjectFromDesiredObjects);

                // generates random integer numbers between 1 and 2
                spriteSidesRandom = Math.floor((randomPos() * 2) + 1);
    
                spritePosgeneratedObstaclesRandom = randomPos() - 0.5;

                if(spriteTypeRandom >= 0 &amp;&amp; spriteTypeRandom &lt;= 99){
                    // choose randomly sprite image
                    // generates random float numbers greater than 0.55
                    spritePosRightRandom = randomPos() + 0.90;
                    // generates random float numbers lesser than -0.55
                    spritePosLeftRandom =  (randomPos() * -0.56) - 0.56;
    
                    // choose randomly sprite size
                    if(spriteSidesRandom == 1){
                        spritePos = spritePosLeftRandom;
                    }else if(spriteSidesRandom == 2){
                        spritePos = spritePosRightRandom;
                    }
                    // console.log(spritePos);
                    if(randomPos() &lt; 0.25){
                        sprite = {type: spritesAvailable[index].value, pos: spritePos-0.5, obstacle: 0};
                    } if(randomPos() &lt; 0.5){
                        sprite = {type: spritesAvailable[index].value, pos: spritePos, obstacle: 0};
                    }else{
                        sprite = {type: spritesAvailable[index].value, pos: 3*spritePos, obstacle: 0};
                    }
                }
                else if(i%obstaclePerIteration==0){
                    // each obstaclePerIteration iterations a new obstacle is placed within the generatedTrack

                    // generates random integer numbers between 0 and objects.length(there are objects.length sprites desired to draw)
                    chooseIndexFromObstacle = Math.floor((randomPos() * objects.length));
                    chooseObstacleFromDesiredObstacle=objects[chooseIndexFromObstacle];
                    index = spritesAvailable.findIndex(el => el.name === chooseObstacleFromDesiredObstacle);
                    // console.log(spritePosgeneratedObstaclesRandom);
                    generatedObstacles.push(spritePosgeneratedObstaclesRandom);
                    // spritePosgeneratedObstaclesRandom has the relative position of the obstacle
                    sprite = {type: spritesAvailable[index].value, pos: spritePosgeneratedObstaclesRandom, obstacle: 1};
                }
                else {
                    sprite = false;
                }
    
                // console.log(sprite);
    
                generatedTrack.push({
                    height: currentZone.height+intendedHeightForCurrentZone / 2 * (1 + Math.sin(i/params.zoneSize * Math.PI-Math.PI/2)),
                    curve: currentZone.curve+intendedCurveForCurrentZone / 2 * (1 + Math.sin(i/params.zoneSize * Math.PI-Math.PI/2)),
                    sprite: sprite
                })
            }
            currentZone.height += intendedHeightForCurrentZone;
            currentZone.curve += intendedCurveForCurrentZone;
    
            // Find next zone
            if(randomPos() &lt; params.mountainy){
                slopesTransitionRandom = 1+Math.round(randomPos());
            }else {
                slopesTransitionRandom = 0;
            }
    
            if(randomPos() &lt; params.curvy){
                curvesTransitionRandom = 1+Math.round(randomPos());
            }else {
                curvesTransitionRandom = 0;
            }
    
            switch(heightType){
                case 0:
                    heightType = slopesTransitions.plainToUpToDownTransition[slopesTransitionRandom]; break;
                case 1:
                    heightType = slopesTransitions.plainToDownToDownTransition[slopesTransitionRandom]; break;
                case -1:
                    heightType = slopesTransitions.plainToUpToUpTransition[slopesTransitionRandom]; break;
            }
    
            switch(curveType){
                case 0:
                    curveType = curvesTransitions.straightToLeftToRightTransition[curvesTransitionRandom]; break;
                case 1:
                    curveType = curvesTransitions.straightToRightToRightTransition[curvesTransitionRandom]; break;
                case -1:
                    curveType = curvesTransitions.straightToLeftToLeftTransition[curvesTransitionRandom]; break;
            }
    
            iter--;
        }
        params.numZones = params.numZones * params.zoneSize;
        // console.log("params.numZones: "+params.numZones);
        // console.log("trackParam.numZones: "+trackParam.numZones);
       
        generatedJSON = {
            controllable_car: controllable_car,
            laneWidth: laneWidth,
            numLanes: numLanes,
            numberOfSegmentPerColor: numberOfSegmentPerColor,
            render: render,
            topSpeed: topSpeed,
            track: generatedTrack,
            trackParam: trackParam,
            trackSegmentSize: trackSegmentSize,
            trackColors: {
                grass1: "#699864",
                border1: "#e00",
                border2: "#fff",
                outborder1: "#496a46",
                outborder_end1: "#474747",
                track_segment1: "#777",
                lane1: "#fff",
                lane2: "#777",
                laneArrow1: "#00FF00",
                track_segment_end:"#000",
                lane_end: "#fff"
            }
        };

        setTimeout(function(){ d3.select("#created").text("Success: True"); }, 1500);
        
        return this;
    };

    /**
     * @function render
     * @description Render method of the TrackGenerator widget. 
     * @memberof module:TrackGenerator
     * @instance
     */
    TrackGenerator.prototype.render = function () {
        return this.reveal();
    };

    module.exports = TrackGenerator;
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Arcade.html">Arcade</a></li><li><a href="module-ButtonExternalController.html">ButtonExternalController</a></li><li><a href="module-Customization.html">Customization</a></li><li><a href="module-DrawGamepad.html">DrawGamepad</a></li><li><a href="module-GamepadController.html">GamepadController</a></li><li><a href="module-Gauge.html">Gauge</a></li><li><a href="module-GyroscopeController.html">GyroscopeController</a></li><li><a href="module-Sound.html">Sound</a></li><li><a href="module-Speedometer.html">Speedometer</a></li><li><a href="module-SteeringWheel.html">SteeringWheel</a></li><li><a href="module-Tachometer.html">Tachometer</a></li><li><a href="module-TrackGenerator.html">TrackGenerator</a></li><li><a href="module-VirtualKeypadController.html">VirtualKeypadController</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue May 22 2018 11:37:45 GMT+0100 (WEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
