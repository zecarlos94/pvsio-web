<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Tutorial: Create a New Simulation</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Tutorial: Create a New Simulation</h1>

    <section>

<header>
    

    <h2>Create a New Simulation</h2>
</header>

<article>
    <p>Guide step-by-step to create a new track with TrackGenerator Widget and, then, render it with Arcade Widget.</p>
<h3>User Steps, using the Customization Widget ( easier )</h3><ol>
<li><strong>Open <a href="http://localhost:8082/demos/arcade_game_simulator/">http://localhost:8082/demos/arcade_game_simulator/</a></strong></li>
<li><strong>Select the image with the desired steering wheel, which will be used during the simulation.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectSteeringWheel.png" alt="selectSteeringWheel" width="700" style="margin-left: 150px" ></p>
<ol start="3">
<li><strong>Use the color pickers to select the track colors.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectTrackColors.png" alt="selectTrackColors" width="700" style="margin-left: 150px" ></p>
<ol start="4">
<li><strong>Insert within the square brackets the topography of the lane that you intend to use in the simulation, i.e., the lane that will be constructed and rendered. Use only the keywords: 'left', 'right' and 'straight' to describe the topography of the track, after &quot;name:&quot;. Use only the keywords: 'flat', 'up' and 'down' to describe the profile/height of the track after &quot;profile:&quot;. Use angles, in degrees, to define the curvature angle after &quot;curvature&quot;. The angle 0 represents a straight line. To represent left curvatures the angle must be between 0 and -90. To represent right curvatures the angle must be between 0 and 90.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectTrackTopography.png" alt="selectTrackTopography" width="700" style="margin-left: 150px" ></p>
<ol start="5">
<li><strong>Insert the spritesheet JSON filename.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectSpritesheetJSON.png" alt="selectSpritesheetJSON" width="700" style="margin-left: 150px" ></p>
<ol start="6">
<li><strong>Insert the spritesheet images filename, one with only letters and other with all objects/obstacles.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectSpritesheetImages.png" alt="selectSpritesheetImages" width="700" style="margin-left: 150px" ></p>
<ol start="7">
<li><strong>Insert within the square brackets the landscape sprites, separated by ','.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectLandscapeObjects.png" alt="selectLandscapeObjects" width="700" style="margin-left: 150px" ></p>
<ol start="8">
<li><strong>Insert within the square brackets the track sprites (obstacles), separated by ','.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectTrackObstacles.png" alt="selectTrackObstacles" width="700" style="margin-left: 150px" ></p>
<ol start="9">
<li><strong>Fill within the brackets each track parameters, after ':'.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectTrackParams.png" alt="selectTrackParams" width="700" style="margin-left: 150px" ></p>
<ol start="10">
<li><strong>Select arcade vehicle, present in both provided spritesheet JSON and png files, in steps 5 and 6.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectArcadeVehicle.png" alt="selectArcadeVehicle" width="700" style="margin-left: 150px" ></p>
<ol start="11">
<li><strong>Select other customization options for the dashboard widgets, which will be used during the simulation, and other rendering aspects using the following set of ranges.</strong></li>
</ol>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectRanges.png" alt="selectRanges" width="700" style="margin-left: 150px" ></p>
<blockquote>
<p>Select the maximum values that the speedometer and tachometer widgets will have, in the 'Value of Speedometer' and 'Value of Tachometer' ranges. </p>
</blockquote>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectRangesSpeedometerTachometer.png" alt="selectRangesSpeedometerTachometer" width="500" style="margin-left: 150px" ></p>
<blockquote>
<p>If the values selected in these ranges are 200 and 9, respectively, and if the steering wheel selected is the porsche steering wheel ( purple steering wheel ), then the final vehicle dashboard, which will be used during the simulation, is</p>
</blockquote>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/customizationResult.png" alt="customizationResult" width="500" style="margin-left: 150px" ></p>
<blockquote>
<p>Select the desired number of lanes, to draw within the track during the simulation, in the 'Number of Lanes' range.</p>
</blockquote>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectRangeLanes.png" alt="selectRangeLanes" width="200" style="margin-left: 300px" ></p>
<blockquote>
<p>Select the frequency of obstacles to be placed within the track during the simulation, in the 'Frequence of Obstacles' range, i.e. choose how many iterations a new obstacle arises.</p>
</blockquote>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectRangesObstacles.png" alt="selectRangesObstacles" width="200" style="margin-left: 300px" ></p>
<blockquote>
<p>Select the desired number of laps, in the 'Number of Laps' range, to be rendered by Arcade widget during the simulation.</p>
</blockquote>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectLaps.png" alt="selectLaps" width="200" style="margin-left: 300px" ></p>
<blockquote>
<p>Choose if Arcade widget will use the PVS instructions during the simulation. By default, i.e. value 0, this widget will use PVS instructions to update the vehicle status during the simulation. This slider allows to test the difference in the rendering processs speed, since PVS instructions turns the simulation much slower than using a self-contained widget that calculates those values.</p>
</blockquote>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/selectPVS.png" alt="selectPVS" width="200" style="margin-left: 300px" ></p>
<blockquote>
<p>To finish the customization, slide the last range to the right.</p>
</blockquote>
<p><img src="/Users/zecarlos/Desktop/pvsio-web/src/client/app/widgets/car/documentation/tutorials_jsdoc/img/endRange.png" alt="EndRange" width="50" style="margin-left: 400px" ></p>
<blockquote>
<p>Although it was not an objective in this dissertation, the widget 'Customization' was created to ease the simulation process. However, since this is not a priority, this widget can be improved over time, for example by adding other customization options that match the optional fields that the TrackGenerator and Arcade widgets have.</p>
</blockquote>
<h3>User Steps, with only manual configurations ( harder )</h3><blockquote>
<p>In this section we present the steps to create a new simulation, using only the Widget APIs developed, which requires a more 'conscious' user. The following steps will be the necessary steps to create a new demo within PVSio-web.</p>
</blockquote>
<blockquote>
<p>Currently it is possible to test the functional demo 'arcade', <a href="http://localhost:8082/demos/arcade_game_simulator/">http://localhost:8082/demos/arcade_game_simulator/</a>, i.e., to test the interactions PVS-Arcade Widget. That is, to use PVS instructions to maintain the simulation state.</p>
</blockquote>
<blockquote>
<p>On demo <a href="http://localhost:8082/demos/track_generator_simulator/">http://localhost:8082/demos/track_generator_simulator/</a> is possible to create a new track using TrackGenerator widget as step 1 will demonstrate.</p>
</blockquote>
<ol>
<li><strong>Create the desired track either using methods that generate the track randomly or using methods that generate the track based on the provided layout.</strong></li>
</ol>
<pre class="prettyprint source"><code>let trackGenerator = {};
// -----------------------------  TRACK GENERATOR COMPONENTS -----------------------------
trackGenerator.trackGeneratorWidget = new TrackGenerator(&quot;trackGeneratorWidget&quot;, {
    top: 80,
    left: 650,
    width: 780,
    height: 650
}, {
    parent: &quot;content&quot;, // defines parent div, which is div id=&quot;body&quot; by default
    spritesFilename: &quot;spritesheet2&quot;, // defines spritesheet configuration filename, which is &quot;spritesheet.json&quot; by default
    render: {
        height: 240,
        depthOfField: 150,
        camera_distance: 30,
        camera_height: 100
    },
    trackSegmentSize: 5,
    numberOfSegmentPerColor: 4,
    numLanes: 3,
    laneWidth: 0.02,
    trackParam: {
        numZones:    12, // number of different portions of the track
        zoneSize:  250 // length of each numZones (the bigger this value. the longer it will take to finish)
    },
    // Information regarding current controllable_car's car
    controllable_car: {
        position: 10,
        speed: 0,
        acceleration: 0.05,
        deceleration: 0.04,
        breaking: 0.3,
        turning: 5.0,
        posx: 0,
        maxSpeed: 20
    },
    objects: [
        {
            filename:&quot;real_tree3&quot;,
            scale: 1,
            positionsX: [
                -0.8,
                0.6
            ]
        },
        {
            filename:&quot;real_tree4&quot;,
            scale: 1,
            positionsX: [
                -0.6,
                0.8
            ]
        },
        {
            filename:&quot;real_building&quot;,
            scale: 1,
            positionsX: [
                -0.7,
                0.9
            ]
        },
        {
            filename:&quot;real_building2&quot;,
            scale: 1,
            positionsX: [
                -0.9,
                0.7
            ]
        },
        {
            filename:&quot;real_skyscraper&quot;,
            scale: 1,
            positionsX: [
                1.9,
                -1.7
            ]
        }
    ],
    obstacle: [
        {
            filename:&quot;30kmh_limit&quot;,
            scale: 1,
            positionsX: [
                0.1
            ]
        },
        {
            filename:&quot;horizontal_pedrestrian_crossing_rubber_bump&quot;,
            scale: 1,
            positionsX: [
                -0.1
            ]
        },
        {
            filename:&quot;traffic_light_red&quot;,
            scale: 1,
            positionsX: [
                0
            ]
        }
    ],
    obstaclePerIteration: 20,
    trackColors: {
        grass1: &quot;#699864&quot;,
        border1: &quot;#e00&quot;,
        border2: &quot;#fff&quot;,
        outborder1: &quot;#496a46&quot;,
        outborder_end1: &quot;#474747&quot;,
        track_segment1: &quot;#777&quot;,
        lane1: &quot;#fff&quot;,
        lane2: &quot;#777&quot;,
        laneArrow1: &quot;#00FF00&quot;,
        track_segment_end:&quot;#000&quot;,
        lane_end: &quot;#fff&quot;
    },
    // trackLayout: [ 
    //     // trackLayout1.json File
    //     // describing the desired track, which is straight line, with 8 zones (8 blocks) and with 
    //     // profiles &quot;flat&quot;.
    //     // Curvature is the angle of curvature for that topography name. This will be useful to try to use 
    //     // those angles to define different curvatures, instead of generating the same curvature for the same
    //     // side
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 8,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          },
    //          {
    //             filename:&quot;under_construction_barrier&quot;,
    //             zone: 3,
    //             scale: 1,
    //             posX: 0.4,
    //             zoneDistance: 100
    //          }
    //         ]
    //     }
    // ],
    trackLayout: [ 
        // trackLayout2.json File
        // describing the desired track, which is curve to left, straight line, 
        // curve to right, straight line, curve to left and straight line each with 3 zones (blocks) and with different 
        // profiles, i.e. &quot;flat&quot; or &quot;up&quot; or &quot;down&quot; allows to define slopes within each zone (default is []).
        // Curvature is the angle of curvature for that topography name. This will be useful to try to use 
        // those angles to define different curvatures, instead of generating the same curvature for the same
        // side
        {
            topography: {
                name:&quot;left&quot;,
                curvature: -90
            },
            profile: &quot;flat&quot;,
            numZones: 3,
            trafficSignals: [
              {
                 filename:&quot;traffic_cone&quot;,
                 scale: 1,
                 zone: 1,
                 posX: -0.4,
                 zoneDistance: 30  (max distance is zoneSize) 
              },
              {
                 filename:&quot;under_construction_barrier&quot;,
                 zone: 3,
                 scale: 1,
                 posX: 0.4,
                 zoneDistance: 100
              }
            ]
        },
        {
            topography: {
                name:&quot;straight&quot;,
                curvature: 0
            },
            profile: &quot;down&quot;,
            numZones: 3,
            trafficSignals: [
              {
                 filename:&quot;traffic_cone&quot;,
                 scale: 1,
                 zone: 1,
                 posX: -0.4,
                 zoneDistance: 30  (max distance is zoneSize) 
              },
              {
                 filename:&quot;under_construction_barrier&quot;,
                 zone: 3,
                 scale: 1,
                 posX: 0.4,
                 zoneDistance: 100
              }
            ]
        },
        {
            topography: {
                name:&quot;right&quot;,
                curvature: 90
            },
            profile: &quot;flat&quot;,
            numZones: 3,
            trafficSignals: [
              {
                 filename:&quot;traffic_cone&quot;,
                 scale: 1,
                 zone: 1,
                 posX: -0.4,
                 zoneDistance: 30  (max distance is zoneSize) 
              },
              {
                 filename:&quot;under_construction_barrier&quot;,
                 zone: 3,
                 scale: 1,
                 posX: 0.4,
                 zoneDistance: 100
              }
            ]
        },
        {
            topography: {
                name:&quot;straight&quot;,
                curvature: 0
            },
            profile: &quot;up&quot;,
            numZones: 3,
            trafficSignals: [
              {
                 filename:&quot;traffic_cone&quot;,
                 scale: 1,
                 zone: 1,
                 posX: -0.4,
                 zoneDistance: 30  (max distance is zoneSize) 
              },
              {
                 filename:&quot;under_construction_barrier&quot;,
                 zone: 3,
                 scale: 1,
                 posX: 0.4,
                 zoneDistance: 100
              }
            ]
        },
        {
            topography: {
                name:&quot;left&quot;,
                curvature: -90
            },
            profile: &quot;flat&quot;,
            numZones: 3,
            trafficSignals: [
              {
                 filename:&quot;traffic_cone&quot;,
                 scale: 1,
                 zone: 1,
                 posX: -0.4,
                 zoneDistance: 30  (max distance is zoneSize) 
              },
              {
                 filename:&quot;under_construction_barrier&quot;,
                 zone: 3,
                 scale: 1,
                 posX: 0.4,
                 zoneDistance: 100
              }
            ]
        },
        {
            topography: {
                name:&quot;straight&quot;,
                curvature: 0
            },
            profile: &quot;flat&quot;,
            numZones: 3,
            trafficSignals: [
              {
                 filename:&quot;traffic_cone&quot;,
                 scale: 1,
                 zone: 1,
                 posX: -0.4,
                 zoneDistance: 30  (max distance is zoneSize) 
              },
              {
                 filename:&quot;under_construction_barrier&quot;,
                 zone: 3,
                 scale: 1,
                 posX: 0.4,
                 zoneDistance: 100
              }
            ]
        }
    ],
    // trackLayout: [ 
    //     // trackLayout3.json File
    //     // describing the desired track, which is straight line, followed by curve to left, straight line, 
    //     // curve to right, straight line and curve to left each with 3 zones (blocks) and with different 
    //     // profiles, i.e. &quot;flat&quot; or &quot;up&quot; or &quot;down&quot; allows to define slopes within each zone (default is []).
    //     // Curvature is the angle of curvature for that topography name. This will be useful to try to use 
    //     // those angles to define different curvatures, instead of generating the same curvature for the same
    //     // side
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;up&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;right&quot;,
    //             curvature: 90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;down&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     }
    // ],
    // trackLayout: [ 
    //     // trackLayout4.json File
    //     // describing the desired track, which is curve to right, with 4 zones (blocks) and with  
    //     // profile &quot;flat&quot;. This layout allows to render a closed circular track (with 4 curves to right 
    //     // where a new curve starts after the previous ends) 
    //     // Curvature is the angle of curvature for that topography name. This will be useful to try to use 
    //     // those angles to define different curvatures, instead of generating the same curvature for the same
    //     // side
    //     {
    //         topography: {
    //             name:&quot;right&quot;,
    //             curvature: 90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 4,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          },
    //          {
    //             filename:&quot;under_construction_barrier&quot;,
    //             zone: 3,
    //             scale: 1,
    //             posX: 0.4,
    //             zoneDistance: 100
    //          }
    //         ]
    //     }
    // ],
    // trackLayout: [ 
    //     // trackLayout5.json File
    //     // describing the desired track, which is curve to left, straight line, 
    //     // curve to left, straight line, curve to left, straight line, curve to left and straight line,
    //     // each with 1 zone (block) and with profile &quot;flat&quot;.
    //     // Curvature is the angle of curvature for that topography name. This will be useful to try to use 
    //     // those angles to define different curvatures, instead of generating the same curvature for the same
    //     // side
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     }
    // ],
    // trackLayout: [ 
    //     // trackLayout6.json File
    //     // describing the desired track, which is curve to left, straight line, 
    //     // curve to right, straight line and curve to left each with 1 zone (block) and with different 
    //     // profiles, i.e. &quot;flat&quot; or &quot;up&quot; or &quot;down&quot; allows to define slopes within each zone (default is []).
    //     // Curvature is the angle of curvature for that topography name. This will be useful to try to use 
    //     // those angles to define different curvatures, instead of generating the same curvature for the same
    //     // side
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;down&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;right&quot;,
    //             curvature: 90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;up&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     }
    // ],
    // trackLayout: [ 
    //     // trackLayout7.json File
    //     // describing the desired track, which is curve to left, with 4 zones (blocks) and with  
    //     // profile &quot;flat&quot;. This layout allows to render a closed circular track (with 4 curves to left 
    //     // where a new curve starts after the previous ends) 
    //     // Curvature is the angle of curvature for that topography name. This will be useful to try to use 
    //     // those angles to define different curvatures, instead of generating the same curvature for the same
    //     // side
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 4,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     }
    // ],
    // trackLayout: [ 
    //     // trackLayout8.json File
    //     // describing the desired track, which is curve to right, straight line, 
    //     // curve to left, straight line and curve to right each with 1 zone (block) and with different 
    //     // profiles, i.e. &quot;flat&quot; or &quot;up&quot; or &quot;down&quot; allows to define slopes within each zone (default is []).
    //     // Curvature is the angle of curvature for that topography name. This will be useful to try to use 
    //     // those angles to define different curvatures, instead of generating the same curvature for the same
    //     // side
    //     {
    //         topography: {
    //             name:&quot;right&quot;,
    //             curvature: 90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;down&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;left&quot;,
    //             curvature: -90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;up&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;right&quot;,
    //             curvature: 90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     }
    // ],
    // trackLayout: [ 
    //     // trackLayout9.json File
    //     // describing the desired track, which is curve to right, straight line, 
    //     // curve to right, straight line, curve to right, straight line, curve to right and straight line,
    //     // each with 1 zone (block) and with profile &quot;flat&quot;.
    //     // Curvature is the angle of curvature for that topography name. This will be useful to try to use 
    //     // those angles to define different curvatures, instead of generating the same curvature for the same
    //     // side
    //     {
    //         topography: {
    //             name:&quot;right&quot;,
    //             curvature: 90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;right&quot;,
    //             curvature: 90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;right&quot;,
    //             curvature: 90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;right&quot;,
    //             curvature: 90
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     },
    //     {
    //         topography: {
    //             name:&quot;straight&quot;,
    //             curvature: 0
    //         },
    //         profile: &quot;flat&quot;,
    //         numZones: 1,
    //         trafficSignals: [
    //          {
    //             filename:&quot;traffic_cone&quot;,
    //             scale: 1,
    //             zone: 1,
    //             posX: -0.4,
    //             zoneDistance: 30 // (max distance is zoneSize) 
    //          }
    //         ]
    //     }
    // ],
    callback: onMessageReceived
});</code></pre><blockquote>
<p>The render method only makes visible the widget div</p>
<pre class="prettyprint source"><code>function render(res) {
    trackGenerator.trackGeneratorWidget.render();
}</code></pre></blockquote>
<blockquote>
<p>The API needed to create, randomly, a track, with only straight lines is</p>
<pre class="prettyprint source"><code>trackGenerator.trackGeneratorWidget.generateStraightTrack();</code></pre></blockquote>
<blockquote>
<p>The API needed to create, randomly, a track, with straight lines, curves and slopes is</p>
<pre class="prettyprint source"><code>trackGenerator.trackGeneratorWidget.generateTrackCurvesSlopes();</code></pre></blockquote>
<blockquote>
<p>The API needed to create the desired track, based on trackLayout opt field provided, is </p>
<pre class="prettyprint source"><code>trackGenerator.trackGeneratorWidget.generateTrackBasedOnTrackLayoutOptField();</code></pre></blockquote>
<blockquote>
<p>To create the track is then only necessary, create the constructor with the optional fields that you want, if none is inserted, the widget will use the following predefined values,</p>
<pre class="prettyprint source"><code>parent: &quot;body&quot;,
spritesFilename: &quot;spritesheet&quot;,
render: {
    depthOfField: 150,
    camera_distance: 30,
    camera_height: 100
},
trackSegmentSize: 5,
numberOfSegmentPerColor: 4,
numLanes: 3,
laneWidth: 0.02,
trackParam: {
    numZones:  12,
    zoneSize:  250
},
controllable_car: {
    position: 10,
    speed: 0,
    acceleration: 0.05,
    deceleration: 0.04,
    breaking: 0.3,
    turning: 5.0,
    posx: 0,
    maxSpeed: 20
},
objects: [],
obstacle: [],
obstaclePerIteration: 50,
trackColors: {
    grass1: &quot;#699864&quot;,
    border1: &quot;#e00&quot;,
    border2: &quot;#fff&quot;,
    outborder1: &quot;#496a46&quot;,
    outborder_end1: &quot;#474747&quot;,
    track_segment1: &quot;#777&quot;,
    lane1: &quot;#fff&quot;,
    lane2: &quot;#777&quot;,
    laneArrow1: &quot;#00FF00&quot;,
    track_segment_end:&quot;#000&quot;,
    lane_end: &quot;#fff&quot;
},
trackLayout: []</code></pre></blockquote>
<blockquote>
<p>The desired layout, 'trackLayout' optional field, will only be translated into canvas segments, which will be represented by the Arcade widget, by the generateTrackBasedOnTrackLayoutOptField() method. The generateStraightTrack() and generateTrackCurvesSlopes() methods can be invoked when the user wants to render random track, with only straight lines or with straight lines, curves and slopes, respectively.</p>
</blockquote>
<blockquote>
<p>Invoking the above APIs ( generateStraightTrack(),generateTrackCurvesSlopes(),generateTrackBasedOnTrackLayoutOptField() ) results in the creation of a JSON file with the following structure,</p>
</blockquote>
<pre class="prettyprint source"><code>generatedJSON = {
    controllable_car: controllable_car,
    laneWidth: laneWidth,
    numLanes: numLanes,
    numberOfSegmentPerColor: numberOfSegmentPerColor,
    render: render,
    track: generatedTrack,
    trackParam: trackParam, // after updating trackParam.numZones with total sum of numZones 
    // in trackLayout opt field
    trackSegmentSize: trackSegmentSize,
    trackColors: trackColors
};</code></pre><blockquote>
<p>Currently, PVSio-web does not have any file-writing APIs in the context of widgets, and as such, the TrackGenerator widget is not able to write the JSON file. Then, the user needs to perform <code>console.log(JSON.stringify(self2.generatedJSON));</code> and copy/paste the result into a JSON file, that is, the user needs to perform the non-existent API process manually. Predefined file names are &quot;track-straight-random.json&quot; or &quot;track-curves-slopes-random.json&quot;, however it is possible to use other file names, since the Arcade widget receives the filename as optional field. </p>
</blockquote>
<blockquote>
<p>When the file-writing API exists, it should be added on lines 471, 739 and 931 with <code>console.log(JSON.stringify(self2.generatedJSON));</code> in <a href="https://github.com/zecarlos94/pvsio-web/tree/gamingDev/src/client/app/widgets/car/TrackGenerator.js">https://github.com/zecarlos94/pvsio-web/tree/gamingDev/src/client/app/widgets/car/TrackGenerator.js</a> file, as well as the filename, as arguments. This file-writing API, must return the filename just created, so it can be used in the pipeline Customization Widget -&gt; TrackGenerator Widget -&gt; Arcade Widget automatically, for more detailed information see <a href="https://github.com/zecarlos94/pvsio-web/tree/gamingDev/src/client/app/widgets/car/Customization.js">https://github.com/zecarlos94/pvsio-web/tree/gamingDev/src/client/app/widgets/car/Customization.js</a> (line 1673 should have the value obtained in line 1659, i.e. the value returned by the file-writing API).</p>
</blockquote>
<blockquote>
<p>Once the JSON file with the desired track has been created, it will be possible to render it using the Arcade widget.</p>
</blockquote>
<ol start="2">
<li><strong>Render the desired track, created previously, i.e. created in step 1.</strong></li>
</ol>
<pre class="prettyprint source"><code>let arcade = {};

// ----------------------------- LINCOLN MKC DASHBOARD DESIGN -----------------------------
arcade.lincolnMKCDashboard = new LincolnMKCDashboard('lincolnMKCDashboard',
    {
        top: 5, left: 0, width: 450, height: 140 
    },{ 
        parent: &quot;content&quot;, // defines parent div, which is div id=&quot;body&quot; by default 
        dashIndex: 1,
        design: &quot;before&quot;, // &quot;after&quot;,
        buttonsPVS: [ &quot;startAndStop&quot;, &quot;activateSportMode&quot;],
        callback: onMessageReceived
        } 
    );

// ----------------------------- DASHBOARD INTERACTION -----------------------------
arcade.up = new ButtonExternalController(&quot;accelerate&quot;, { width: 0, height: 0 }, {
    callback: onMessageReceived,
    evts: ['press/release'],
    keyCode: 38 // key up
});
arcade.down = new ButtonExternalController(&quot;brake&quot;, { width: 0, height: 0 }, {
    callback: onMessageReceived,
    evts: ['press/release'],
    keyCode: 40 // key down
});

// ----------------------------- DASHBOARD COMPONENTS -----------------------------
// ---------------- SPEEDOMETER ----------------
arcade.speedometerGauge = new Speedometer('speedometer-gauge', {
    label: &quot;kmh&quot;,
    max: 260,
    min: 0
});
// ---------------- TACHOMETER ----------------
arcade.tachometerGauge = new Tachometer('tachometer-gauge', {
    max: 9,
    min: 0,
    label: &quot;x1000/min&quot;
});

// ---------------- STEERING WHEEL ----------------
arcade.steeringWheel = new SteeringWheel(&quot;steering_wheel&quot;, {
    top: 220,
    left: 20,
    width: 600,
    height: 600
}, {
    style: &quot;ferrari&quot;,
    callback: onMessageReceived
});

// ----------------------------- ARCADE GAME COMPONENTS -----------------------------
arcade.arcadeWidget = new Arcade(&quot;arcadeWidget&quot;, {
    top: 300,
    left: 860,
    width: 320,
    height: 240
}, {
    parent: &quot;content&quot;, // defines parent div, which is div id=&quot;body&quot; by default
    scaleWindow: 1, // scales canvas div
    trackFilename: &quot;trackLayout2&quot;,// &quot;track-curves-slopes-random&quot;, // &quot;track-straight-random&quot;, // defines track configuration filename, which is &quot;track-curves-slopes-random.json&quot; by default
    spritesFilename: &quot;spritesheet2&quot;, // defines spritesheet configuration filename, which is &quot;spritesheet.json&quot; by default
    spritesFiles: [&quot;spritesheet2&quot;,&quot;spritesheet.text&quot;], // defines all spritesheets(images). Default are &quot;spritesheet.png&quot; and &quot;spritesheet.text.png&quot;
    realisticImgs: false,
    vehicle: &quot;car&quot;, // available vehicles: [&quot;airplane&quot;,&quot;bicycle&quot;,&quot;car&quot;,&quot;helicopter&quot;,&quot;motorbike&quot;]
    vehicleImgIndex: 2, // defines vehicle sprite image suffix
    // logoImgIndex: 1, // defines logo sprite image suffix
    // backgroundImgIndex: 1, // defines background sprite image suffix
    stripePositions: {
        trackP1: -0.55,
        trackP2: 0.55,
        borderWidth: 0.08,
        inOutBorderWidth: 0.02,
        landscapeOutBorderWidth: 0.13,
        diffTrackBorder: 0.05,
        finishLineP1: -0.40,
        finishLineP2: 0.40,
        diffLanesFinishLine: 0.05
    },
    lapNumber: 3,
    // showOfficialLogo: true,
    loadPVSSpeedPositions: false,
    // predefinedTracks: 4,
    // newLap_functionNamePVS: &quot;new_lap&quot;,
    // action_attribute: &quot;action&quot;,
    // direction_attribute: &quot;direction&quot;,
    // sound_attribute: &quot;sound&quot;,
    // lap_attribute: &quot;lap&quot;,
    // speed_attribute: &quot;speed&quot;,
    // posx_attribute: &quot;posx&quot;,
    // position_attribute: &quot;position&quot;,
    // lap_value: &quot;val&quot;,
    // speed_value: &quot;val&quot;,
    // posx_value: &quot;val&quot;,
    // position_value: &quot;val&quot;,
    // left_attribute: &quot;left&quot;,
    // right_attribute: &quot;right&quot;,
    // straight_attribute: &quot;straight&quot;,
    // accelerate_attribute: &quot;acc&quot;,
    // brake_attribute: &quot;brake&quot;,
    // idle_attribute: &quot;idle&quot;,
    // quit_attribute: &quot;quit&quot;,
    // pause_attribute: &quot;pause&quot;,
    // resume_attribute: &quot;resume&quot;,
    // mute_attribute: &quot;mute&quot;,
    // unmute_attribute: &quot;unmute&quot;,
    callback: onMessageReceived
});

// ----------------------------- ARCADE GAME INTERACTION -----------------------------
arcade.resume = new ButtonExternalController(&quot;resume&quot;, { width: 0, height: 0 }, {
    callback: onMessageReceived,
    evts: ['press/release'],
    keyCode: 32 // key space
});
arcade.pause = new ButtonExternalController(&quot;pause&quot;, { width: 0, height: 0 }, {
    callback: onMessageReceived,
    evts: ['press/release'],
    keyCode: 83 // key 's'
});
arcade.quit = new ButtonExternalController(&quot;quit&quot;, { width: 0, height: 0 }, {
    callback: onMessageReceived,
    evts: ['press/release'],
    keyCode: 81 // key 'q'
});
arcade.mute = new ButtonExternalController(&quot;mute&quot;, { width: 0, height: 0 }, {
    callback: onMessageReceived,
    evts: ['press/release'],
    keyCode: 77 // key 'm'
});
arcade.unmute = new ButtonExternalController(&quot;unmute&quot;, { width: 0, height: 0 }, {
    callback: onMessageReceived,
    evts: ['press/release'],
    keyCode: 85 // key 'u'
});</code></pre><blockquote>
<p>For a new simulation it is necessary to add not only the Arcade widget, which renders the track, but also the widgets whose designs will be 'tested', as is the case of the steering wheel, speedometer, tachometer, among others. It is also necessary to add all the buttons that will allow to invoke the formal specifications, defined in the main.pvs file inside the demo folder that is being created, e.g. resume, pause, quit, mute, unmute, accelerate and brake actions.</p>
</blockquote>
<blockquote>
<p>It should be noted that if the JSON file, with the desired track, created in step 1, used the spritesheet 'spritesheet.json', whose sprites are present in the 'spritesheet.png' and 'spritesheet.text.png' images, then the Arcade widget, to correctly represent the track, must receive the same files, in 'spritesFilename' and 'spritesFiles' optional fields. All spritesheets must have the .png extension, since it is the extension that is being added by default, to simplify the values received in the optional fields. </p>
</blockquote>
<blockquote>
<p>To create the spritesheet JSON file and spritesheet image it is recommended to use the tool <a href="https://www.codeandweb.com/texturepacker">https://www.codeandweb.com/texturepacker</a>, which allows to add and group the different images. Using 'publish' functionality the JSON file, with the coordinates of each image, and the spritesheet image, with .png extension, will be created.</p>
</blockquote>
<blockquote>
<p>The API needed to start the new simulation is</p>
<pre class="prettyprint source"><code>arcade.arcadeWidget.startSimulation();</code></pre></blockquote>
<blockquote>
<p>The render method renders the speedometer, tachometer, steering wheel and arcade widgets</p>
<pre class="prettyprint source"><code>function render(res) {
    arcade.speedometerGauge.render(evaluate(res.speed.val));
    arcade.tachometerGauge.render(evaluate(res.rpm));
    arcade.steeringWheel.render(evaluate(res.steering));
    arcade.arcadeWidget.render(res);
}</code></pre></blockquote>
<blockquote>
<p>To render the track is then only necessary, create the constructor with the optional fields that you want, if none is inserted, the widget will use the following predefined values,</p>
<pre class="prettyprint source"><code>parent: &quot;body&quot;, 
trackFilename: &quot;track-curves-slopes-random&quot;, 
spritesFilename: &quot;spritesheet&quot;, 
spritesFiles: [&quot;spritesheet&quot;,&quot;spritesheet.text&quot;], 
realisticImgs: false,
vehicle: &quot;car&quot;, 
vehicleImgIndex: null, 
logoImgIndex: null,
backgroundImgIndex: null,
stripePositions: {
    trackP1: -0.55,
    trackP2: 0.55,
    borderWidth: 0.08,
    inOutBorderWidth: 0.02,
    landscapeOutBorderWidth: 0.13,
    diffTrackBorder: 0.05,
    finishLineP1: -0.40,
    finishLineP2: 0.40,
    diffLanesFinishLine: 0.05
},
lapNumber: 2,
showOfficialLogo: false,
loadPVSSpeedPositions: true,
predefinedTracks: null,
newLap_functionNamePVS: &quot;new_lap&quot;,
action_attribute: &quot;action&quot;,
direction_attribute: &quot;direction&quot;,
sound_attribute: &quot;sound&quot;,
lap_attribute: &quot;lap&quot;,
speed_attribute: &quot;speed&quot;,
posx_attribute: &quot;posx&quot;,
position_attribute: &quot;position&quot;,
lap_value: &quot;val&quot;,
speed_value: &quot;val&quot;,
posx_value: &quot;val&quot;,
position_value: &quot;val&quot;,
left_attribute: &quot;left&quot;,
right_attribute: &quot;right&quot;,
straight_attribute: &quot;straight&quot;,
accelerate_attribute: &quot;acc&quot;,
brake_attribute: &quot;brake&quot;,
idle_attribute: &quot;idle&quot;,
quit_attribute: &quot;quit&quot;,
pause_attribute: &quot;pause&quot;,
resume_attribute: &quot;resume&quot;,
mute_attribute: &quot;mute&quot;,
unmute_attribute: &quot;unmute&quot;,</code></pre></blockquote>
<blockquote>
<p>Predefined file name is &quot;track-curves-slopes-random.json&quot;, which has the arcade simulation with all different topographies. If user wants to use predefined tracks, it is only necessary to add the integer suffix of the corresponding file in predefinedTracks opt field. That is, to use trackLayout6.json, the user must set 'predefinedTracks: 6' and the Arcade widget will render the track present in trackLayout6.json file.</p>
</blockquote>
<ol start="3">
<li><strong>Necessary PVS Code</strong></li>
</ol>
<blockquote>
<p>In order to the Arcade widget work it will be necessary to use formal specifications, in pvs/main.pvs file, written with the formal language PVS as it follows,</p>
</blockquote>
<pre class="prettyprint source"><code>% ---------------------------------------------------------------
%  Theory: car_demo
%  Author: Paolo Masci and Jose Carlos
%          INESC TEC and Universidade do Minho
% ---------------------------------------------------------------

main: THEORY
 BEGIN

  Gear: TYPE = { P, N, R, GEAR_1, GEAR_2, GEAR_3, GEAR_4, GEAR_5, GEAR_6 }
  gear2real(g: Gear): real =
    COND
     g = P OR g = N -> 0,
     g = R -> 3.67,
     g = GEAR_1 -> 3.78,
     g = GEAR_2 -> 2.06,
     g = GEAR_3 -> 1.23,
     g = GEAR_4 -> 0.83,
     g = GEAR_5 -> 0.7,
     g = GEAR_6 -> 0.6
    ENDCOND
  CONVERSION gear2real

  MAX_SPEED: real = 300
  Speed_Unit: TYPE = { kpm, mph }
  Speed_Val: TYPE = { x: real | x &lt;= MAX_SPEED }
  Speed: TYPE = [#
    val: Speed_Val,
    units: Speed_Unit
  #]

  MAX_RPM: real = 14
  Rpm: TYPE = { x: nonneg_real | x &lt;= MAX_RPM }

  MAX_ODO: real = 999999
  Odo: TYPE = { x: nonneg_real | x &lt;= MAX_ODO }

  TEMP_AMB: real = 16.1
  Temp_Units: TYPE = { C, F }
  Temp: TYPE = [#
    val: real,
    units: Temp_Units
  #]

  POSITION_INIT: real = 10.0
  Position: TYPE = [#
    val: real
  #]

  POSX_INIT: real = 0.0
  PosX: TYPE = [#
    val: real
  #]

  LAP_INIT: real = 1.0
  Lap: TYPE = [#
    val: real
  #]

  Action: TYPE = { idle, acc, brake, pause, resume, quit }
  Direction: TYPE = { left, right, straight }
  Sound: TYPE = { unmute, mute }
  Startstopbutton: TYPE = { off, on }
  Sportmodebutton: TYPE = { off, on }
  Time: TYPE = [# hour: int, min: int #]

  state: TYPE = [#
    speed: Speed, % Km/h
    gear: Gear,
    rpm: Rpm, % x1000/min
    odo: Odo, % Km
    temp: Temp,
    time: Time,
    steering: real,
    position: Position,
    posx: PosX,
    action: Action,
    direction: Direction,
    sound: Sound,
    startstopbutton: Startstopbutton,
    sportmodebutton: Sportmodebutton,
    lap: Lap
  #]

  get_current_time: Time = (# hour := get_time`hour, min := get_time`minute #)

  %-- initial state
  init(x: real): state = (#
    speed := (# val:= IF x &lt; MAX_SPEED THEN x ELSE MAX_SPEED ENDIF, units := kpm #),
    gear := N,
    rpm := 0,
    odo := 0,
    temp := (# val := TEMP_AMB, units := C #),
    time := get_current_time,
    steering := 0,
    position := (# val := POSITION_INIT  #),
    posx := (# val := POSX_INIT #),
    action := idle,
    direction := straight,
    sound := unmute,
    startstopbutton := off,
    sportmodebutton := off,
    lap := (# val := LAP_INIT #)
  #)

  %-- utility functions
  tyre: real = 7.30 %-- tyre circumference, in feet
  % this function converts speed into rpms based on the gear and tyre size
  getRPM(st: state): Rpm =
    LET new_rpm = (speed(st)`val * gear(st) * 440) / tyre / 1000
     IN COND
          new_rpm &lt; 0 -> 0,
      new_rpm > MAX_RPM -> MAX_RPM,
      ELSE -> new_rpm
    ENDCOND

  getAcc(g: Gear): Speed_Val =
   COND
     g = P OR g = N -> 0,
     g = R -> -0.6,
     g = GEAR_1 -> 0.6,
     g = GEAR_2 -> 1.2,
     g = GEAR_3 -> 1,
     g = GEAR_4 -> 0.8,
     g = GEAR_5 -> 0.6,
     g = GEAR_6 -> 0.3
   ENDCOND

  getAccSportMode(g: Gear): Speed_Val =
   COND
      g = P OR g = N -> 0,
      g = R -> -5,
      g = GEAR_1 -> 1.3,
      g = GEAR_2 -> 1.5,
      g = GEAR_3 -> 1.8,
      g = GEAR_4 -> 2,
      g = GEAR_5 -> 2.2,
      g = GEAR_6 -> 2.5
   ENDCOND

  getBrk(g: Gear): [# speed: real, rpm: real #] = (# speed := -2, rpm := -1 #)

  getBrkSportMode(g: Gear): [# speed: real, rpm: real #] = (# speed := -8, rpm := -2 #)

  gearUP(st: state): state =
    LET g = gear(st) IN
    COND
     g = P OR g = N OR g = R -> st,
     g = GEAR_1 -> st WITH [ gear := GEAR_2 ],
     g = GEAR_2 -> st WITH [ gear := GEAR_3 ],
     g = GEAR_3 -> st WITH [ gear := GEAR_4 ],
     g = GEAR_4 -> st WITH [ gear := GEAR_5 ],
     g = GEAR_5 -> st WITH [ gear := GEAR_6 ],
     g = GEAR_6 -> st
    ENDCOND
  gearDOWN(st: state): state =
    LET g = gear(st) IN
    COND
     g = P OR g = N OR g = R -> st,
     g = GEAR_1 -> st,
     g = GEAR_2 -> st WITH [ gear := GEAR_1 ],
     g = GEAR_3 -> st WITH [ gear := GEAR_2 ],
     g = GEAR_4 -> st WITH [ gear := GEAR_3 ],
     g = GEAR_5 -> st WITH [ gear := GEAR_4 ],
     g = GEAR_6 -> st WITH [ gear := GEAR_5 ]
    ENDCOND

  accelerate(st: state): state =
    LET st = st WITH [ gear := IF gear(st) = N THEN GEAR_1 ELSE gear(st) ENDIF ],
        step = getAcc(gear(st)),
        st = IF speed(st)`val + step &lt; MAX_SPEED
             THEN st WITH [ speed := speed(st) WITH [ val:= speed(st)`val + step ]]
         ELSE st WITH [ speed := speed(st) WITH [ val:= MAX_SPEED ]] ENDIF,
    new_rpm = getRPM(st),
    st = st WITH [ rpm := new_rpm ]%, position := position(st) WITH [ val:= position(st)`val + speed(st)`val ]]
     IN IF rpm(st) > 6 THEN gearUP(st) ELSE st ENDIF

  accelerateSportMode(st: state): state =
    LET st = st WITH [ gear := IF gear(st) = N THEN GEAR_1 ELSE gear(st) ENDIF ],
        step = getAccSportMode(gear(st)),
        st = IF speed(st)`val + step &lt; MAX_SPEED
             THEN st WITH [ speed := speed(st) WITH [ val:= speed(st)`val + step ]]
         ELSE st WITH [ speed := speed(st) WITH [ val:= MAX_SPEED ]] ENDIF,
    new_rpm = getRPM(st),
    st = st WITH [ rpm := new_rpm ]%, position := position(st) WITH [ val:= position(st)`val + speed(st)`val ]]
     IN IF rpm(st) > 6 THEN gearUP(st) ELSE st ENDIF

  brake(st: state): state =
    LET step = getBrk(gear(st)),
        st = IF speed(st)`val >= 0
         THEN st WITH [ speed := speed(st) WITH
              [ val := IF speed(st)`val + step`speed > 0
                   THEN speed(st)`val + step`speed
                   ELSE 0 ENDIF ]]
         ELSE %-- the car was driving in reverse, so the speed was negative
                  st WITH [ speed := speed(st) WITH
                  [ val:= IF speed(st)`val - step`speed &lt; 0
                  THEN speed(st)`val - step`speed
                  ELSE 0 ENDIF ]] ENDIF,
    new_rpm = getRPM(st),
        st = st WITH [ rpm := new_rpm ]%, position := position(st) WITH [ val:= position(st)`val + speed(st)`val ]]
     IN IF rpm(st) &lt; 4 THEN gearDOWN(st) ELSE st ENDIF

  brakeSportMode(st: state): state =
    LET step = getBrkSportMode(gear(st)),
        st = IF speed(st)`val >= 0
         THEN st WITH [ speed := speed(st) WITH
              [ val := IF speed(st)`val + step`speed > 0
                   THEN speed(st)`val + step`speed
                   ELSE 0 ENDIF ]]
         ELSE %-- the car was driving in reverse, so the speed was negative
                  st WITH [ speed := speed(st) WITH
                  [ val:= IF speed(st)`val - step`speed &lt; 0
                  THEN speed(st)`val - step`speed
                  ELSE 0 ENDIF ]] ENDIF,
    new_rpm = getRPM(st),
        st = st WITH [ rpm := new_rpm ]%, position := position(st) WITH [ val:= position(st)`val + speed(st)`val ]]
     IN IF rpm(st) &lt; 4 THEN gearDOWN(st) ELSE st ENDIF

  FRICTION: Speed_Val = 0.6
  inc(odo: Odo, speed: Speed): Odo =
    LET step = speed`val / 60 * 1
     IN IF step >= 0
        THEN IF odo + step &lt;= MAX_ODO THEN odo + step ELSE odo + step - MAX_ODO ENDIF
    ELSE IF odo + step &lt;= 0 THEN 0 ELSE odo + step ENDIF ENDIF

  POSX_STEP: real = 25 
  tick(st: state): state =
   LET st = st WITH [ time := get_current_time,
                      position := position(st) WITH [ val:= position(st)`val + speed(st)`val ]]
    IN IF speed(st)`val > 0
       THEN LET new_speed: Speed_Val = COND action(st) = idle -> IF speed(st)`val - FRICTION > 0 THEN speed(st)`val - FRICTION ELSE 0 ENDIF,
                                            ELSE -> speed(st)`val ENDCOND,
            st = st WITH [ speed := speed(st) WITH [ val := new_speed ]]
         IN st WITH [ rpm := getRPM(st),
                      odo := inc(odo(st), speed(st)),
              posx := posx(st) WITH [ val := COND steering(st) >= 20 -> posx(st)`val + POSX_STEP,
                                                  steering(st) &lt;= -20 -> posx(st)`val - POSX_STEP,
                                  ELSE -> posx(st)`val ENDCOND ],
                  direction := COND steering(st) >= 20 -> right,
                        steering(st) &lt;= -20 -> left,
                        ELSE -> straight ENDCOND ]
        ELSE st ENDIF


  %-- APIs
  press_accelerate(st: state): state = IF sportmodebutton(st) = off
                                        THEN accelerate(st) WITH [ action := acc ]
                                        ELSE accelerateSportMode(st) WITH [ action := acc ]
                                      ENDIF
  release_accelerate(st: state): state = st WITH [ action := idle ]

  press_brake(st: state): state = IF sportmodebutton(st) = off
                                    THEN brake(st) WITH [ action := brake ]
                                    ELSE brakeSportMode(st) WITH [ action := brake ]
                                  ENDIF
  release_brake(st: state): state = st WITH [ action := idle ]

  STEERING_STEP: real = 20 %deg
  steering_wheel_right(st: state): state = st WITH [ steering := IF steering(st) &lt; 90 THEN steering(st) + STEERING_STEP ELSE 90 ENDIF ]
  steering_wheel_left(st: state): state = st WITH [ steering := IF steering(st) > -90 THEN steering(st) - STEERING_STEP ELSE -90 ENDIF ]
  steering_wheel_straight(st: state): state = st WITH [ steering := 0, posx := posx(st) WITH [ val:= posx(st)`val ], direction := straight ]
  steering_wheel_rotate(x: real)(st: state): state = st WITH [ steering := x ]

  %-- API for new laps
  LAP_STEP: real = 1.0 
  new_lap(st: state): state = st WITH [  position := (# val := POSITION_INIT  #), lap := lap(st) WITH [ val:= lap(st)`val + LAP_STEP ] ]

  %-- API for sound controls 
  press_mute(st: state): state = st WITH [ sound := mute ]
  release_mute(st: state): state = st WITH [ sound := mute ]

  press_unmute(st: state): state = st WITH [ sound := unmute ]
  release_unmute(st: state): state = st WITH [ sound := unmute ]

  %-- API for virtual Keypad controller 
  %-- TODO create the interactions with Arcade Driving Simulator
  press_quit(st: state): state = st WITH [ action := quit, startstopbutton := off ]
  release_quit(st: state): state = st WITH [ action := idle ]
  press_pause(st: state): state = st WITH [ action := pause, startstopbutton := off ]
  release_pause(st: state): state = st WITH [ action := idle ]
  press_resume(st: state): state = st WITH [ action := resume, startstopbutton := on ]
  release_resume(st: state): state = st WITH [ action := idle ]

  %-- API for external controllers such as PS4 gamepad
  click_accelerate(st: state): state = IF sportmodebutton(st) = off
                                        THEN accelerate(st) WITH [ action := acc ]
                                        ELSE accelerateSportMode(st) WITH [ action := acc ]
                                      ENDIF
  click_brake(st: state): state = IF sportmodebutton(st) = off
                                    THEN brake(st) WITH [ action := brake ]
                                    ELSE brakeSportMode(st) WITH [ action := brake ]
                                  ENDIF

  %-- API for external controller interactive image
  press_rightArrow(st: state): state = steering_wheel_right(st)
  release_rightArrow(st: state): state = st

  press_leftArrow(st: state): state = steering_wheel_left(st)
  release_leftArrow(st: state): state = st

  %-- API for case study 2015 Lincoln MCK interactive dashboard image
  startAndStop(st: state): state = 
    LET st = IF startstopbutton(st) = off
              THEN st WITH [ action := resume, startstopbutton := on ]
              ELSE st WITH [ action := quit, startstopbutton := off ] 
             ENDIF
    IN st 

  activateSportMode(st: state): state = 
    LET st = IF sportmodebutton(st) = off
              THEN st WITH [ sportmodebutton := on ]
              ELSE st WITH [ sportmodebutton := off ] 
             ENDIF
    IN st 

  press_startAndStop(st: state): state = startAndStop(st)
  release_startAndStop(st: state): state = st WITH [ action := idle ]

  press_activateSportMode(st: state): state = activateSportMode(st)
  release_activateSportMode(st: state): state = st WITH [ action := idle ]

END main</code></pre><blockquote>
<p>This set of specifications was leveraged from the demo 'car', <a href="http://localhost:8082/demos/car/">http://localhost:8082/demos/car/</a>, and developed in order to add the necessary parameters, to maintain the state of the simulation. The modifications that were added were,</p>
</blockquote>
<pre class="prettyprint source"><code>POSITION_INIT: real = 10.0
Position: TYPE = [#
    val: real
#]

POSX_INIT: real = 0.0
PosX: TYPE = [#
    val: real
#]

LAP_INIT: real = 1.0
Lap: TYPE = [#
    val: real
#]

Action: TYPE = { idle, acc, brake, pause, resume, quit }
Direction: TYPE = { left, right, straight }
Sound: TYPE = { unmute, mute }

state: TYPE = [#
    speed: Speed, % Km/h
    gear: Gear,
    rpm: Rpm, % x1000/min
    odo: Odo, % Km
    temp: Temp,
    time: Time,
    steering: real,
    position: Position,
    posx: PosX,
    action: Action,
    direction: Direction,
    sound: Sound,
    lap: Lap
#]

getAccSportMode(g: Gear): Speed_Val =
    COND
      g = P OR g = N -> 0,
      g = R -> -5,
      g = GEAR_1 -> 1.3,
      g = GEAR_2 -> 1.5,
      g = GEAR_3 -> 1.8,
      g = GEAR_4 -> 2,
      g = GEAR_5 -> 2.2,
      g = GEAR_6 -> 2.5
    ENDCOND

getBrk(g: Gear): [# speed: real, rpm: real #] = (# speed := -2, rpm := -1 #)

getBrkSportMode(g: Gear): [# speed: real, rpm: real #] = (# speed := -8, rpm := -2 #)

accelerateSportMode(st: state): state =
    LET st = st WITH [ gear := IF gear(st) = N THEN GEAR_1 ELSE gear(st) ENDIF ],
        step = getAccSportMode(gear(st)),
        st = IF speed(st)`val + step &lt; MAX_SPEED
             THEN st WITH [ speed := speed(st) WITH [ val:= speed(st)`val + step ]]
         ELSE st WITH [ speed := speed(st) WITH [ val:= MAX_SPEED ]] ENDIF,
    new_rpm = getRPM(st),
    st = st WITH [ rpm := new_rpm ]%, position := position(st) WITH [ val:= position(st)`val + speed(st)`val ]]
     IN IF rpm(st) > 6 THEN gearUP(st) ELSE st ENDIF

brakeSportMode(st: state): state =
    LET step = getBrkSportMode(gear(st)),
        st = IF speed(st)`val >= 0
         THEN st WITH [ speed := speed(st) WITH
              [ val := IF speed(st)`val + step`speed > 0
                   THEN speed(st)`val + step`speed
                   ELSE 0 ENDIF ]]
         ELSE %-- the car was driving in reverse, so the speed was negative
                  st WITH [ speed := speed(st) WITH
                  [ val:= IF speed(st)`val - step`speed &lt; 0
                  THEN speed(st)`val - step`speed
                  ELSE 0 ENDIF ]] ENDIF,
    new_rpm = getRPM(st),
        st = st WITH [ rpm := new_rpm ]%, position := position(st) WITH [ val:= position(st)`val + speed(st)`val ]]
     IN IF rpm(st) &lt; 4 THEN gearDOWN(st) ELSE st ENDIF

press_startAndStop(st: state): state = startAndStop(st)
release_startAndStop(st: state): state = st WITH [ action := idle ]

press_activateSportMode(st: state): state = activateSportMode(st)
release_activateSportMode(st: state): state = st WITH [ action := idle ]</code></pre><blockquote>
<p>Position, PosX and Speed allows to set the vehicle's position and speed during the simulation. Sound allows the Arcade widget to know when to mute/unmute the audio files, using the Sound widget API. PosX value changes based on the steering wheel rotation. Position value changes based on actions 'accelerate'/'brake' and the current speed value. Actions 'pause','resume' and 'quit' allows the Arcade widget to reveal the 'pause','resume' and 'quit' menus, respetively. Lap allows to set multiple laps in the simulation, updating the current lap number when new_lap function is invoked.</p>
</blockquote>
<blockquote>
<p>Specifications 'startAndStop' and 'activateSportMode' are defining the behaviour, in the realistic demo done for the conference ICGI 2018 paper. That is, is the specification that allows to simulate the activation of the sport mode when the proper button is clicked and observe the design issue/flaw reported by many drivers, which led its manufacturer to recall the vehicles and replace that design. </p>
</blockquote>
</article>

</section>

</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Arcade.html">Arcade</a></li><li><a href="module-Customization.html">Customization</a></li><li><a href="module-TrackGenerator.html">TrackGenerator</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-Arcade.html">Create a New Simulation</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Jul 15 2018 19:35:54 GMT+0100 (WEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>